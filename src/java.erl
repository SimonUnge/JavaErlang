%% Copyright (c) 2011, Lars-Ake Fredlund
%% All rights reserved.
%%
%% Redistribution and use in source and binary forms, with or without
%% modification, are permitted provided that the following conditions are met:
%%     %% Redistributions of source code must retain the above copyright
%%       notice, this list of conditions and the following disclaimer.
%%     %% Redistributions in binary form must reproduce the above copyright
%%       notice, this list of conditions and the following disclaimer in the
%%       documentation and/or other materials provided with the distribution.
%%     %% Neither the name of the copyright holders nor the
%%       names of its contributors may be used to endorse or promote products
%%       derived from this software without specific prior written permission.
%%
%% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ''AS IS''
%% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
%% IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
%% ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS AND CONTRIBUTORS
%% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
%% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
%% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
%% BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
%% WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
%% OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
%% ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

%% @doc This module implements a facility for invoking Java code
%% (methods, constructors, fields) from Erlang, using the JInterface library.
%% @author Lars-Ake Fredlund (lfredlund@fi.upm.es)
%% @copyright 2011 Lars-Ake Fredlund
%%

%% Wishlist:
%%
%% - Supporting synchronized? This possibly means to lock, and synchronize
%% on a variable, a particular thread in JavaErlang until it is unlocked
%% (possible on the level of JNI).
%%
%% - Permit calling constructors and methods on non-public classes, and
%% non-public constructors and methods of public classes.
%%
%% - If a field is final, don't generate a setter function.
%%

-module(java).


-include_lib("kernel/include/file.hrl").

-include("node.hrl").
-include("class.hrl").
-include("tags.hrl").

-export([init/1]).
-export([connect/2,start_node/0,start_node/1,nodes/0]).
-export([default_options/0,version/0]).
-export([free/1,reset/1,terminate/1,terminate_all/0]).
-export([brutally_terminate/1,recreate_node/1]).
-export([node_id/1,node_is_alive/1]).
-export([new/3,new/4]).
-export([call/3,call/4,call_static/4,call_static/5]).
-export([eq/2]).
-export([set_timeout/1]).
-export([get/2,get_static/3,set/3,set_static/4]).
-export([is_object_ref/1]).
-export([array_to_list/1,string_to_list/1,string_to_utf8/1,list_to_string/2,list_to_array/3,convert/3]).
-export([getClassName/1,getSimpleClassName/1,instanceof/2,is_subtype/3]).
-export([identity/1]).
-export([print_stacktrace/1,get_stacktrace/1]).
-export([set_loglevel/1,format/2,format/3]).
-export([acquire_class/2,acquire_class/3,report_java_exception/1]).
-export([memory_usage/0,memory_usage/1]).
-export([print_class/2]).

%% Private
-export([javaCall/3]).
-export([get_option/2]).
-export([finalComponent/1]).
-export([find_class/1]).
-export([node_lookup/1]).
-export([run_java/10]).
-export([terminate_brutally/1]).

-include("debug.hrl").

-export_type([node_id/0,object_type/0,object_ref/0,value/0,type/0]).

-type loglevel() ::
        all | none |
        alert | critical | debug | emergency | error | info | notice | warning.

-type option() ::
        {symbolic_name,string()}
      | {java_class,string()}
      | {add_to_java_classpath,[string()]}
      | {java_classpath,[string()]}
      | {java_exception_as_value,boolean()}
      | {java_verbose,string()}
      | {java_executable,string()}
      | {enter_classes,[{atom()}]}
      | {erlang_remote,string()}
      | {log_level,loglevel()}
      | {enable_gc,boolean()}
      | {ping_timeout,integer()}
      | {connection_timeout,integer()}
      | {java_options,[string()]}
      | {setcookie,string()}
      | {enable_proxies,boolean()}
      | {return_OtpErlangObject,boolean()}
      | {call_timeout,integer() | infinity}.
%% <ul>
%% <li>`symbolic_name' provides a symbolic name for the node.</li>
%% <li>`java_classpath' provides a classpath to the Java executable.
%% The default classpath includes the OtpErlang.jar library, and
%% the Java class files needed by the JavaErl library.</li>
%% <li>`add_to_java_classpath' adds additional entries to an
%% existing classpath established by java_classpath.</li>
%% <li>`java_exception_as_value' determines whether exceptions
%% generated by a Java runtime is delivered as a tuple
%% "{java_exception,Object}" or as an Erlang exception
%% with the above tuple as cause.</li>
%% <li>`java_executable' determines which program will be used
%% to start the Java interpreter (by default "java").</li>
%% <li>`java_verbose' provides diagnostic output from the
%% Java interface class using the Java standard logger.</li>
%% <li>`java_options' permits specifying command line options
%% to the Java executable.</li>
%% <li>`enter_classes' specifies the classes whose members
%% (fields or methods) should be accessible
%% although they are not declared public.</li>.
%% <li>`erlang_remote' specifies a (possibly remote)
%% Erlang node which is responsible
%% for starting the new Java node.</li>
%% <li>`ping_timeout' sets the multiple ping/pong timeout (in milliseconds), 
%% which is used to permit multiple ping/pong attempts. 
%% The current default value is (5000ms = 5s).</li>
%% <li>`conncetion_timeout' sets the connection timeout, in milliseconds,
%% for when a connection is setup, typically to increase the current
%% default value (1000ms = 1s).</li>
%% <li>`enable_gc' determines whether to garbage collect
%% Java objects communicated to Erlang or not.</li>
%% <li>`enable_proxies' determines whether the proxy facility provided
%% <li>`setcookie' sets the cookie for the Java node.</li>
%% <li>`return_OtpErlangObject' determines whether objects of type OtpErlangObject are returned directly to Erlang (if the option is false), or not.</li>
%% <li>`call_timeout' sets a timeout value for all calls
%% to Java from Erlang (default 10 seconds).</li>
%% </ul>

-opaque node_id() :: integer().
%%-type node_id() :: integer().
%% Identifies a connected Java node.

%% Likely to change.
%%-opaque object_type() :: object | executable | thread.
-opaque object_type() :: object.

-type object_ref() :: {object_type(), integer(), integer(), integer(), node_id()}.
%% A Java object reference.

-type class_name() :: atom() | string().
%% A Java classname, e.g., the quoted atom 'java.lang.Integer'.

-type class_ref() :: class_name() | object_type().

-type method_name() :: atom().
%% A name of a Java method, e.g., the atom 'toString'.

-type attribute_name() :: atom().
%% A name of a Java attribute, represented as an atom.

-type type() :: primitive_type() | class_name() | array_type().
%% The representation of a Java types as an Erlang term.

-type array_type() :: {array,type(),integer()}.

-type value() :: object_ref() | number() |
                 null | true | false | void | array_value() |
                 value_spec().

-type java_number() :: integer() | float().

-type value_spec() :: {int_type(), integer()} |
                      {float_type(), float()} |
                      {class_name, object_ref()} |
                      {array_type(), array_value()}.

-type array_value() :: string() | [value()].

-type primitive_type() :: int_type() | float_type().

-type number_type() :: int_type() | float_type().
-type int_type() :: int | long | short | char | byte .
-type float_type() :: float | double.

%% @doc Starts a Java node and establises the connection
%% to Erlang. Returns a Java library "node identifier" (not a normal
%% Erlang node identifier).
%%
-spec start_node() -> {ok,node_id()} | {error,any()}.
start_node() ->
    start_node([]).

%% @doc Starts a Java node and establishes the connection
%% to Erlang. UserOptions provides options for how
%% Java is started.
%% Returns a "Java library node identifier" (not a normal
%% Erlang node identifier).
%% To make your Java classes (and Jar files) visible to the library
%% the option ``add_to_java_classpath'' should be provided to
%% ``java:start_node/1''. An example:<br/>
%% ```
%% {ok,NodeId} = java:start_node([{add_to_java_classpath,["classes"]}]).
%% '''
%% Adds the directory ``classes''
%% to the classpath of the started Java interpreter.
%%
-spec start_node([option()]) -> {ok,node_id()} | {error,any()}.
start_node(UserOptions) ->
    check_net_kernel(),
    Options = UserOptions++default_options(),
    check_options(Options),
    LogLevel = proplists:get_value(log_level,Options),
    EnableGC = proplists:get_value(enable_gc,Options,false),
    ConnectionTimeout = proplists:get_value(connection_timeout,Options,1000),
    PingPongTimeout = proplists:get_value(ping_timeout,Options,5000),
    EnableProxies = proplists:get_value(enable_proxies,Options,false),
    init([{log_level,LogLevel}]),
    CallTimeout = proplists:get_value(call_timeout,Options),
    ReturnOtpErlangObject = proplists:get_value(return_OtpErlangObject,Options,true),
    SymbolicName = proplists:get_value(symbolic_name,Options,void),
    EnteredClasses = proplists:get_value(enter_classes,Options,[]),
    NodeNode = proplists:get_value(erlang_remote,Options,node()),
    Cookie = proplists:get_value(setcookie,Options,undefined),
    if
        EnableProxies -> java_proxy:start();
        true -> ok
    end,
    PreNode =
        #node{options=Options,
              call_timeout=CallTimeout,
              node_node=NodeNode,
              enable_gc=EnableGC,
	      connect_timeout=ConnectionTimeout,
	      cookie=Cookie,
	      enter_classes=EnteredClasses,
              return_OtpErlangObject=ReturnOtpErlangObject,
	      ping_retry=PingPongTimeout,
              symbolic_name=SymbolicName},
    spawn_java(PreNode,get_java_node_id()).

check_net_kernel() ->
    case whereis(net_kernel) of
        undefined ->
            format
              (error,
               "*** Error: net_kernel system process is not running.~n"++
                   "Make sure to start erlang using \"erl -sname nodename ...\"~nor "++
                   "call net_kernel:start/1~n~n"),
            throw(net_kernel_undefined);
        _ ->
            ok
    end.

spawn_java(PreNode,PreNodeId) ->
    SymbolicName = PreNode#node.symbolic_name,
    if PreNode#node.num_start_tries>=PreNode#node.max_java_start_tries ->
            format(error,"*** Error: ~p: failed to start Java~n",[SymbolicName]),
            {error,too_many_tries};
       true ->
            NodeId = PreNodeId+99,
            Options = PreNode#node.options,
            JavaVerbose = proplists:get_value(java_verbose,Options),
            JavaOptions = proplists:get_value(java_options,Options),
            ClassPath = compute_classpath(Options),
            NodeName =
                list_to_atom(node_part(NodeId,SymbolicName)++host_part(PreNode)),
  	    Cookie = PreNode#node.cookie,
            PortPid =
                spawn
                  (PreNode#node.node_node,
                   ?MODULE,
                   run_java,
                   [
                    NodeId,
                    NodeName,
                    SymbolicName,
                    proplists:get_value(java_executable,Options),
                    JavaVerbose,
                    JavaOptions,
                    ClassPath,
		    Cookie,
                    proplists:get_value(java_class,Options),
                    proplists:get_value(return_OtpErlangObject,Options)
                   ]),
            PreNode1 =
                PreNode#node{node_id=NodeId,
                             node_name=NodeName,
                             port_pid=PortPid},
            case connectToNode(PreNode1) of
                {ok,Node} ->
                    java:format
                      (debug,"~p: connect succeeded with pid ~p~n",
                       [Node#node.node_name,Node#node.node_pid]),
                    node_store(Node),
                    java:format
                      (debug,
                       "~p: fresh connection to ~p established~n",
                       [Node#node.node_name,NodeId]),
                    {ok,NodeId};
                {error,Reason} ->
                    java:format
                      (warning,
                       "~p: failed to connect at try ~p with reason ~p~n",
                       [PreNode1#node.node_name,
                        PreNode1#node.num_start_tries,Reason]),
                    spawn_java
                      (PreNode1#node{num_start_tries=PreNode1#node.num_start_tries+1},
                       NodeId)
            end
    end.

compute_classpath(Options) ->
    ClassPath =
        proplists:get_value(java_classpath,Options),
    AllAdditionals =
        proplists:get_all_values(add_to_java_classpath,Options),
    lists:foldl(fun (CPs,CP) -> CPs++CP end, ClassPath, AllAdditionals).

check_options(Options) ->
    lists:foreach
      (fun (Option) ->
	       OptionName = 
		   case Option of
		       {Name,_} when is_atom(Name) -> Name;
		       Name when is_atom(Name) -> Name
		   end,
	       case lists:member
		   (OptionName,
		    [symbolic_name,log_level,enable_gc,enable_proxies,
		     erlang_remote,
		     java_class,java_classpath,add_to_java_classpath,
		     java_exception_as_value,java_timeout_as_value,
		     connection_timeout,ping_timeout,
		     java_verbose,java_options,
		     setcookie,
		     enter_classes,
		     java_executable,call_timeout]) of
		   true -> ok;
		   false ->
		       format
			 (error,
			  "*** error: option ~p to java:start_node not understood~n",
			  [OptionName]),
		       throw(badarg)
	       end
       end, Options).

%% @private
get_option(Option,NodeId) ->
    get_option(Option,NodeId,undefined).

get_option(Option,NodeId,Default) ->
    {ok,Node} = node_lookup(NodeId),
    proplists:get_value(Option,Node#node.options,Default).

get_java_node_id() ->
    ets:update_counter(java_nodes,java_node_counter,1).

%% @private
run_java(Identity,NodeName,Name,Executable,Verbose,JavaOptions,Paths,Cookie,Class,ReturnOtpErlangObject) ->
    ClassPath =
        case combine_paths(Paths) of
            "" -> [];
            PathSpec -> ["-cp",PathSpec]
        end,
    CookieArg = 
        if Cookie=/=undefined -> ["-setcookie",Cookie]; true -> [] end,
    VerboseArg =
        if Verbose=/=undefined -> ["-loglevel",Verbose]; true -> [] end,
    JavaOptionsArgs =
        if JavaOptions=/=undefined -> JavaOptions; true -> [] end,
    ReturnOtpErlangObjectArg =
        if ReturnOtpErlangObject==true -> []; true -> ["-returnOtpErlangObject"] end,
    Args =
        JavaOptionsArgs++
        ClassPath++
        [Class,NodeName]++
        VerboseArg++CookieArg++ReturnOtpErlangObjectArg,
    format
      (info,
       "~p: starting Java node at ~p with command~n~s and args ~p~n",
       [Name,
        net_adm:localhost(),
        Executable,
        Args]),
    Port =
        open_port
          ({spawn_executable,Executable},
           [{line,1000},stderr_to_stdout,{args,Args}]),
    java_reader(Port,Identity).

combine_paths(Paths) ->
    Combinator =
        case runs_on_windows() of
            true -> ";";
            _ -> ":"
        end,
    combine_paths(Combinator,Paths).

combine_paths(_,[]) ->  "";
combine_paths(_,[P]) ->  P;
combine_paths(Combinator,[P|Rest]) -> P++Combinator++combine_paths(Rest).

java_reader(Port,Identity) ->
    receive
        {to_port,Data} ->
            Port!{self(), {command, Data}},
            java_reader(Port,Identity);
        {control,terminate_reader} ->
            ok;
        {_,{data,{eol,Message}}} ->
            io:format("~s~n",[Message]),
            java_reader(Port,Identity);
        {_,{data,{noeol,Message}}} ->
            io:format("~s~n",[Message]),
            java_reader(Port,Identity);
        Other ->
            format
              (warning,
               "java_reader ~p got strange message~n  ~p~n",[Identity,Other]),
            java_reader(Port,Identity)
    end.

%% @doc Connects to an already started Java node.
%% Returns a Java library "node identifier" (not a normal
%% Erlang node identifier).
%%
-spec connect(atom(),[option()]) -> {ok,node_id()} | {error,any()}.
connect(NodeName,UserOptions) ->
    check_net_kernel(),
    Options = UserOptions++default_options(),
    check_options(Options),
    LogLevel = proplists:get_value(log_level,Options),
    init([{log_level,LogLevel}]),
    CallTimeout = proplists:get_value(call_timeout,Options),
    NodeId = get_java_node_id(),
    PreNode =
        #node
        {node_id=NodeId,
	 options=Options,
         call_timeout=CallTimeout,
         node_name=NodeName},
    case connectToNode(PreNode) of
        {ok,Node} ->
            java:format
              (debug,"~p: connect succeeded with pid ~p~n",
               [Node#node.node_name,Node#node.node_pid]),
            node_store(Node),
            java:format
              (debug,
               "~p: fresh connection to ~p established~n",
               [Node#node.node_name,NodeId]),
            {ok,NodeId};
        Error = {error,Reason} ->
            java:format
              (warning,
               "~p: failed to connect with reason ~p~n",
               [PreNode#node.node_name,Reason]),
            Error
    end.

connectToNode(Node) ->
    connectToNode
      (Node,
       addTimeStamps(java_timestamp(),milliSecondsToTimeStamp(Node#node.ping_retry))).

connectToNode(PreNode,KeepOnTryingUntil) ->
    NodeName = PreNode#node.node_name,
    java:format
      (debug,"trying to connect to Java node ~p~n",
       [NodeName]),
    case net_adm:ping(NodeName) of
        pong ->
            java:format
              (debug,"connected to Java node ~p~n",
               [NodeName]),
            {javaNode,NodeName}!{?connect,PreNode#node.node_id,self()},
            connect_receive(NodeName,PreNode,KeepOnTryingUntil);
        pang ->
            case compareTimes_ge(java_timestamp(),KeepOnTryingUntil) of
                true ->
                    format
                      (warning,
                       "*** Warning: failed trying to connect to Java node ~p~n",
                       [NodeName]),
                    {error,timeout};
                false ->
                    timer:sleep(100),
                    connectToNode(PreNode,KeepOnTryingUntil)
            end
    end.

connect_receive(NodeName,PreNode = #node{node_id=NodeId},KeepOnTryingUntil) ->
    receive
        {value,{connected,NodeId,Pid,UnixPid}} when is_pid(Pid) ->
            java:format
              (debug,"~p: got Java pid ~p~n",
               [NodeName,Pid]),
            GC_pid =
            if 
              PreNode#node.enable_gc -> 
                spawn_link(fun () -> handle_gc() end);
              true ->
                void
            end,
            Monitor_pids = spawn_link(fun () -> monitor_pids() end),
            Node = PreNode#node{node_pid=Pid,unix_pid=UnixPid,monitor_pids=Monitor_pids,gc_pid=GC_pid},
            {ok,Node};
      Msg={value,{connected,_,_,_}} ->
	java:format
	  (warning,"~p: WARNING. Got reply to old Java connection attempt ~p~n",
	   [NodeName,Msg]),
	connect_receive(NodeName,PreNode,KeepOnTryingUntil);
      {value,already_connected} ->
            %% Oops. We are talking to an old Java node...
            %% We should try to start another one...
            {error,already_connected};
        Other ->
            format
              (warning,
               "*** ~p: Warning: got reply ~p instead of a pid "++
                   "when trying to connect to node ~p~n",
               [NodeName,Other,{javaNode,NodeName}]),
            connect_receive(NodeName,PreNode,KeepOnTryingUntil)
    after PreNode#node.connect_timeout ->
            %% Failed to connect. We should try to start another node.
            {error,connect_timeout}
    end.

monitor_pids() ->
    receive
        {do_monitor,Pid} ->
            format(debug,"monitor_pids will monitor ~p~n",[Pid]),
            monitor(process,Pid),
            monitor_pids();
        {'DOWN',_,_,Pid,_} ->
            [{_,Threads}] = ets:lookup(java_threads,Pid),
            lists:foreach
              (fun ({Thread,NodeId}) ->
                       format
                         (debug,
                          "monitor_pids taking down thread ~p at ~p due to termination of ~p~n",
                          [Thread,NodeId,Pid]),
                       try javaSend(NodeId,?stopThread,Thread)
                       catch _:_ -> ok end
               end, Threads),
            monitor_pids();
        Other ->
            format
              (warning,
               "*** Warning: monitor_pids() got message ~p~n",
               [Other]),
            monitor_pids()
    end.

handle_gc() ->
    receive
        Msg ->
            try
                javaSend(node_id(Msg),?freeInstance,Msg)
            catch _:_ -> ok end,
            handle_gc()
    end.

compareTimes_ge({M1,S1,Mic1}, {M2,S2,Mic2}) ->
    M1 > M2
        orelse (M1 =:= M2 andalso S1 > S2)
        orelse (M1 =:= M2 andalso S1 =:= S2 andalso Mic1 >= Mic2).

milliSecondsToTimeStamp(MilliSeconds) ->
    Seconds = MilliSeconds div 1000,
    MegaSeconds = Seconds div 1000000,
    {MegaSeconds, Seconds rem 1000000, MilliSeconds rem 1000 * 1000}.

addTimeStamps({M1,S1,Mic1},{M2,S2,Mic2}) ->
    Mic=Mic1+Mic2,
    MicRem = Mic rem 1000000,
    MicDiv = Mic div 1000000,
    S = S1+S2+MicDiv,
    SRem = S rem 1000000,
    SDiv = S div 1000000,
    M = M1+M2+SDiv,
    {M,SRem,MicRem}.

node_part(Identity,void) ->
    IdentityStr = integer_to_list(Identity),
    "javaNode_"++IdentityStr;
node_part(_,SymbolicName) ->
    SymbolicName.

host_part(Node) ->
    NodeStr =
        case Node#node.node_node of
            void ->
                atom_to_list(node());
            _ ->
                atom_to_list(Node#node.node_node)
        end,
    string:substr(NodeStr,string:str(NodeStr,"@")).

%% @private
-spec javaCall(node_id(),integer(),any()) -> any().
javaCall(NodeId,Type,Msg) when is_integer(Type), Type>=0, Type=<?last_tag ->
    javaCall(NodeId,Type,Msg,true).

javaCall(NodeId,Type,Msg,Warn) when is_integer(Type), Type>=0, Type=<?last_tag ->
    case node_lookup(NodeId,Warn) of
        {ok, Node} ->
            JavaMsg = create_msg(Type,Msg,Node),
            case permit_output(get_loglevel(),debug) of
	      true -> 
		java:format
		  (debug,"to_java(~p): ~s:~p ~n",
		   [NodeId,msgtype_to_list(Type),Msg]);
	      false -> 
		ok
            end,
            Node#node.node_pid!JavaMsg,
	waiting_for_reply(Msg,Type,Node);
      _ ->
	if
	  Warn ->
	    format(error,"javaCall: nodeId ~p not found~n",[NodeId]),
	    format
	      (error,
	       "type: ~s message: ~p~n",[msgtype_to_list(Type),Msg]),
	    throw(javaCall);
	  true ->
	    fail
	end
    end.

waiting_for_reply(Msg,Type,Node) ->
  case wait_for_reply(Node) of

    %% The first clause is to ensure that objects references
    %% are garbage collected only after any call involving them
    %% returns. 
    %% This is to preven a race between handling an object Call
    %% on the Java side, and the gc message arriving from Erlang
    %% to the Java side.
    zzzzz ->
      self()!Msg,
      throw(impossible);

    %% Guard against old connection replies arriving; probably we 
    %% should instead use a counter for all messages and throw away
    %% all messages out-of-sequence.
    Msg={connected,_,Pid,_} when is_pid(Pid) ->
      java:format
	(warning,
	 "warning: got old reply to connection attempt from Java:~n~p~n",
	 [Msg]),
      waiting_for_reply(Msg,Type,Node);
      
    Reply ->
      case permit_output(get_loglevel(),debug) of
	true -> 
	  java:format
	    (debug,
	     "from_java: ~s:~p -> ~p~n",
	     [msgtype_to_list(Type),Msg,Reply]);
	false -> 
	  ok
      end,
      if
	Node#node.enable_gc ->
	  enable_gc(Reply,Node#node.gc_pid);
	true ->
	  Reply
      end
  end.

%% @private
-spec javaSend(node_id(),integer(),any()) -> any().
javaSend(NodeId,Type,Msg) when is_integer(Type), Type>=0, Type=<?last_tag ->
    case node_lookup(NodeId,false) of
        {ok, Node} ->
            JavaMsg = {Type,Msg},
            Node#node.node_pid!JavaMsg;
        _ ->
            format(debug,"javaCall: nodeId ~p not found~n",[NodeId]),
            format(debug,"type: ~p message: ~p~n",[Type,Msg]),
            throw(javaSend)
    end.

enable_gc(D={object,Key,_Counter,ClassId,NodeId},GC) ->
    Resource = java_resource:create(D,GC),
    {object,Key,Resource,ClassId,NodeId};
enable_gc(T,GC) when is_tuple(T) ->
    list_to_tuple(enable_gc(tuple_to_list(T),GC));
enable_gc([First|Rest],GC) ->
    [enable_gc(First,GC)|enable_gc(Rest,GC)];
enable_gc(Item,_GC) ->
    Item.

create_msg(Type,Msg,Node) ->
    case msg_type(Type) of
        thread_msg ->
            {Type,get_thread(Node),Msg,self()};
        non_thread_msg ->
            {Type,Msg,self()}
    end.

msg_type(Tag) when Tag=<?last_nonthreaded_tag ->
    non_thread_msg;
msg_type(_) ->
    thread_msg.

wait_for_reply(Node) ->
    Timeout = get_timeout(Node),
    receive
	{'EXIT',_Pid,normal} ->
	    wait_for_reply(Node);
	{value,Val} ->
	    Val;
	_Exc={exception,ExceptionValue} ->
	    case proplists:get_value(java_exception_as_value,Node#node.options,false) of
		true ->
		    {java_exception,ExceptionValue};
		false ->
		    throw_java_exception(ExceptionValue)
	    end
	    %%    Other -> 
	    %%      io:format
	    %%	("~p(~p) at pid ~p~nstrange message ~p received~n",
	    %%	 [Node#node.symbolic_name,Node#node.node_id,self(),Other]),
	    %%      wait_for_reply(Node)
    after Timeout -> 
	    case proplists:get_value(java_timeout_as_value,Node#node.options,false) of
		true ->
		    java_timeout;
		false ->
		    throw(java_timeout) 
	    end
    end.

throw_java_exception(ExceptionValue) ->
    throw({java_exception,ExceptionValue}).

report_java_exception({java_exception,Exception}) ->
    io:format("*** Warning: unexpected Java exception:~n"),
    Err = get_static(node_id(Exception),'java.lang.System',err),
    call(Exception,printStackTrace,[Err]),
    throw_java_exception(Exception);
report_java_exception(Other) ->
    Other.

create_thread(NodeId) ->
    javaCall(NodeId,?createThread,0).

get_thread(Node) ->
    NodeId = Node#node.node_id,
    Self = self(),
    case ets:lookup(java_threads,{NodeId,Self}) of
        [{_,Thread}] ->
            Thread;
        _ ->
            Thread = create_thread(NodeId),
            ThreadsPerPid =
                case ets:lookup(java_threads,Self) of
                    [] -> [];
                    [{_,ThreadsPP}] -> ThreadsPP
                end,
            NewThreadsPerPid = [{Thread,NodeId}|ThreadsPerPid],
            ets:insert(java_threads,{Self,NewThreadsPerPid}),
            ets:insert(java_threads,{{Node#node.node_id,Self},Thread}),
            Node#node.monitor_pids!{do_monitor,Self},
            Thread
    end.

%% @private
%% @doc
%% An identity function for Java objects.
identity(Value) ->
    javaCall(node_id(Value),?identity,Value).

%% @doc
%% Calls the constructor of a Java class.
%% Returns an object reference.
%% <p>
%% Example: ``java:new(NodeId,'java.util.HashSet',[])'',
%% corresponding to the statement `new HashSet()'.
%% </p>
%% <p>
%% Due to the rules of Java method application (see explanation note in
%% module description)
%% it is possible that the correct constructor
%% for its arguments cannot be found. In that case,
%% `new/4' should be used intead.
%% </p>
-spec new(node_id(),class_name(),[value()]) -> object_ref().
new(NodeId,ClassName,Args) when is_list(Args) ->
    ?LOG("NodeId=~p ClassName=~p~n",[NodeId,ClassName]),
    Constructor = java_to_erlang:find_constructor(NodeId,ClassName,Args),
    javaCall(NodeId,?call_constructor,{Constructor,list_to_tuple(Args)}).

%% @doc
%% Calls the constructor of a Java class, explicitely selecting
%% a particular constructor.
%% Returns an object reference.
%% <p>
%% Example:
%%     ``java:new(NodeId,'java.lang.Integer',[int],[42])'',
%% corresponding to the statement
%% `new Integer(42)'.
%% </p>
-spec new(node_id(),class_name(),[type()],[value()]) -> object_ref().
new(NodeId,ClassName,ArgTypes,Args) when is_list(Args) ->
    ?LOG("NodeId=~p ClassName=~p~n",[NodeId,ClassName]),
    Constructor =
        java_to_erlang:find_constructor_with_type(NodeId,ClassName,ArgTypes),
    javaCall(NodeId,?call_constructor,{Constructor,list_to_tuple(Args)}).

%% @doc
%% Calls a Java instance method.
%% Example:
%%     ``java:call(Object,toString,[])'',
%% corresponding to the call `Object.toString()'.
-spec call(object_ref(),method_name(),[value()]) -> value().
call(Object,Method,Args) when is_list(Args) ->
    ensure_non_null(Object),
    JavaMethod = java_to_erlang:find_method(Object,Method,Args),
    javaCall(node_id(Object),?call_method,{Object,JavaMethod,list_to_tuple(Args)}).

%% @doc
%% Calls a Java instance method, explicitely
%% selecting a particular method, using the type argument to
%% distinguish between methods of the same arity.
-spec call(object_ref(),method_name(),[type()],[value()]) -> value().
call(Object,Method,ArgTypes,Args) when is_list(Args) ->
    ensure_non_null(Object),
    JavaMethod =
        java_to_erlang:find_method_with_type(Object,Method,ArgTypes),
    javaCall(node_id(Object),?call_method,{Object,JavaMethod,list_to_tuple(Args)}).

%% @doc
%% Calls a Java static method (a class method).
%% Example:
%%     ``java:call_static(NodeId,'java.lang.Integer',reverseBytes,[22])'',
%% corresponding to the call `Integer.reverseBytes(22)'.
-spec call_static(node_id(),class_name(),method_name(),[value()]) -> value().
call_static(NodeId,ClassName,Method,Args) when is_list(Args) ->
    JavaMethod =
        java_to_erlang:find_static_method(NodeId,ClassName,Method,Args),
    javaCall(NodeId,?call_method,{null,JavaMethod,list_to_tuple(Args)}).

%% @doc
%% Calls a Java static method (a class method). Explicitely
%% selects which method to call using the types argument.
-spec call_static(node_id(),class_name(),method_name(),[type()],[value()]) -> value().
call_static(NodeId,ClassName,Method,ArgTypes,Args) when is_list(Args) ->
    JavaMethod =
        java_to_erlang:find_static_method_with_type
          (NodeId,ClassName,Method,ArgTypes),
    javaCall(NodeId,?call_method,{null,JavaMethod,list_to_tuple(Args)}).

%% @doc
%% Retrieves the value of an instance attribute.
%% Example:
%% ``java:get(Object,v)', corresponding to 'Object.v''.
-spec get(object_ref(), attribute_name()) -> value().
get(Object,Field) ->
    ensure_non_null(Object),
    JavaField = java_to_erlang:find_field(Object,Field),
    javaCall(node_id(Object),?getFieldValue,{Object,JavaField,null}).

%% @doc
%% Retrieves the value of a class attribute.
%% Example:
%% ``java:get_static(NodeId,'java.lang.Integer','SIZE')'',
%% corresponding to `Integer.SIZE'.
-spec get_static(node_id(), class_name(), attribute_name()) -> value().
get_static(NodeId,ClassName,Field) ->
    JavaField = java_to_erlang:find_static_field(NodeId,ClassName,Field),
    javaCall(NodeId,?getFieldValue,{null,JavaField,null}).

%% @doc
%% Modifies the value of an instance attribute.
-spec set(object_ref(), attribute_name(), value()) -> value().
set(Object,Field,Value) ->
    ensure_non_null(Object),
    JavaField = java_to_erlang:find_field(Object,Field),
    javaCall(node_id(Object),?setFieldValue,{Object,JavaField,Value}).

%% @doc
%% Modifies the value of a static, i.e., class attribute.
-spec set_static(node_id(), class_name(), attribute_name(), value()) -> value().
set_static(NodeId,ClassName,Field,Value) ->
    JavaField = java_to_erlang:find_static_field(NodeId,ClassName,Field),
    javaCall(NodeId,?setFieldValue,{null,JavaField,Value}).

%% @doc
%% Checks if two Java objects references refer to the same object.
%% Note that using normal Erlang term equality is not safe.
-spec eq(object_ref(),object_ref()) -> boolean().
eq({object,Id,_,_,NodeId},{object,Id,_,_,NodeId}) ->
    true;
eq(_,_) ->
    false.

%% @doc Initializes the Java interface library
%% providing default options.
%% It is called automatically by `start_node/0' and
%% `standard_node/1'. Calling `init/1' explicitely is
%% useful to customize the library when multiple
%% Java connections are used.
-spec init([option()]) -> boolean().
init(UserOptions) ->
    DefaultOptions = default_options(),
    Options = UserOptions++DefaultOptions,
    open_db(Options).

%% open_db() ->
%%   open_db(false,void).

open_db(Options) ->
    open_db(true,Options).

open_db(Init,Options) ->
    SelfPid = self(),
    case ets:info(java_nodes) of
        undefined ->
            spawn(fun () ->
                          %%io:format("spawned db ~p~n",[self()]),
		          JavaNodeCounter = rand:uniform(100),
                          try
                              ets:new(java_nodes,[named_table,public]),
                              ets:insert(java_nodes,{java_node_counter,JavaNodeCounter}),
                              ets:new(java_classes,[named_table,public]),
                              ets:new(java_threads,[named_table,public]),
                              ets:new(java_class_ids,[named_table,public]) of
			    _ -> 
                              wait_until_stable(),
                              if
                                  Init ->
                                      ets:insert(java_nodes,{options,Options});
                                  true ->
                                      ok
                              end,
                              SelfPid!{initialized,true},
                              wait_forever()
                          catch _:_ ->
                                  wait_until_stable(),
                                  SelfPid!{initialized,false}
                                  %%io:format("terminating db ~p~n",[self()])
                          end
                  end),
            receive
                {initialized,DidInit} -> DidInit
            end;
        _ ->
            wait_until_stable(),
            false
    end.

wait_until_stable() ->
    case {ets:info(java_nodes),
          ets:info(java_classes),
          ets:info(java_threads),
          ets:info(java_class_ids)} of
        {Info1,Info2,Info3,Info4}
          when is_list(Info1), is_list(Info2), is_list(Info3), is_list(Info4) ->
            ok;
        _ ->
            timer:sleep(10),
            wait_until_stable()
    end.

wait_forever() ->
    receive _ -> wait_forever() end.

%% @doc
%% Returns a list with the default options.
-spec default_options() -> [option()].
default_options() ->
    [
     {Name, default_option(Name)} ||
        Name <- [
                 java_class,
                 java_classpath,
                 java_executable,
                 call_timeout,
                 log_level
                ]
    ].

default_option(java_class) ->
    "javaErlang.JavaErlang";
default_option(java_classpath) ->
    OtpClassPath =
        case code:priv_dir(jinterface) of
            {error,_} -> [];
            OtpPath when is_list(OtpPath) ->
                [OtpPath++"/OtpErlang.jar"]
        end,
    JavaErlangClassPath =
        case code:priv_dir(java_erlang) of
            {error,_} -> [];
            JavaErlangPath when is_list(JavaErlangPath) ->
                [JavaErlangPath++"/JavaErlang.jar",JavaErlangPath++"/javassist.jar"]
        end,
    ClassPath = OtpClassPath++JavaErlangClassPath++["."],
    ?LOG("Java classpath is ~p~n",[ClassPath]),
    ClassPath;
default_option(java_executable) ->
    case os:find_executable("java") of
        false -> "java";
        Executable -> Executable
    end;
default_option(call_timeout) ->
    10000;
default_option(log_level) ->
    notice.

%% @doc
%% Returns the major version number of the JavaErlang library.
-spec version() -> string().
version() ->
    case [ Vsn || {java_erlang, _, Vsn} <- application:loaded_applications() ] of
        [] ->
            "unknown";
        [Vsn] ->
            Vsn
    end.

%% @doc Returns the node where the object argument is located.
-spec node_id(object_ref()) -> node_id().
node_id({_,_,_,_,NodeId}) ->
    NodeId.

%% @doc Returns true if the node is alive, false otherwise.
-spec node_is_alive(object_ref()) -> boolean().
node_is_alive(NodeId) ->
  case node_lookup(NodeId,false) of
    {ok,_} ->
      true;
    Other ->
      Other
  end.

%% -spec object_id(object_ref()) -> integer().
%% object_id({_,ObjectId,_,_,_}) ->
%%   ObjectId.

-spec class_id(object_ref()) -> integer().
class_id({_,_,_,ClassId,_}) ->
  ClassId.


%% %% @doc
%% %% Returns the symbolic name of a Java node.
%% -spec symbolic_name(node_id()) -> string().
%% symbolic_name(NodeId) ->
%%   {ok,Node} = node_lookup(NodeId),
%%   Node#node.symbolic_name.

%% @doc
%% Returns the set of active Java nodes.
-spec nodes() -> [node_id()].
nodes() ->
    case ets:info(java_nodes) of
        undefined -> [];
        _ ->
            lists:foldl
              (fun ({NodeId,_},Acc) when is_integer(NodeId) -> [NodeId|Acc];
                   (_,Acc) -> Acc
               end, [],
               ets:tab2list(java_nodes))
    end.

%% @doc
%% Resets the state of a Java node, i.e.,
%% the object proxy is reset.
%% This operation will cause all Java object references
%% existing to become invalid (i.e., not referring to
%% any Java object), but references to Java methods, constructors
%% or fields are not affected. In addition all threads created are
%% eventually stopped, and a new thread created to service future
%% calls. Note that the function call may return before all threads
%% have stopped.
-spec reset(node_id()) -> any().
reset(NodeId) ->
    %% Threads are removed, so we have to clean up the Erlang thread table
    remove_thread_mappings(NodeId),
    javaCall(NodeId,?reset,void).

%% @doc
%% Shuts down and terminates the connection to a Java node.
-spec terminate(node_id()) -> any().
terminate(NodeId) ->
    javaCall(NodeId,?terminate,void,false),
    remove_thread_mappings(NodeId),
    remove_class_mappings(NodeId),
    case node_lookup(NodeId,false) of
      {ok,Node} when is_record(Node,node) ->
	Node#node.port_pid!{control,terminate_reader},
	ets:delete(java_nodes,NodeId);
      _ -> ok
    end.

%% @doc
%% Shuts down and terminates the connection to all known Java nodes.
-spec terminate_all() -> any().
terminate_all() ->
    case ets:info(java_nodes) of
        undefined -> ok;
        _ ->
            lists:foreach
              (fun ({NodeId,_Node}) when is_integer(NodeId) ->
                       javaCall(NodeId,?terminate,void,false),
                       {ok,Node} = node_lookup(NodeId,false),
                       Node#node.port_pid!{control,terminate_reader};
                   (_) -> ok
               end, ets:tab2list(java_nodes)),
            ets:delete(java_nodes),
            ets:delete(java_classes),
            ets:delete(java_class_ids),
            ets:delete(java_threads)
    end.

%% @doc
%% Brutally shuts down and terminates the connection to a Java node.
%% Does not send a termination message to the Java node, instead it
%% attempts to kill the Unix process corresponding to the Java runtime system
%% of the node. This will obviously only work under Unix/Linux.
-spec brutally_terminate(node_id()) -> any().
brutally_terminate(NodeId) ->
    {ok,Node} = node_lookup(NodeId),
    remove_thread_mappings(NodeId),
    remove_class_mappings(NodeId),
    ets:delete(java_nodes,NodeId),
    spawn(Node#node.node_node,?MODULE,terminate_brutally,[Node]).

%% @private
terminate_brutally(Node) ->
    case runs_on_windows() of
        true ->
            java:format
              (error,
               "*** Error: ~p: brutally_terminate not supported under windows~n",
               [Node#node.symbolic_name]),
            throw(nyi);
        _ -> ok
    end,
    Node#node.port_pid!{control,terminate_reader},
    os:cmd(io_lib:format("kill -9 ~p",[Node#node.unix_pid])).

%% @doc
%% Recreates a possibly dead node. Obviously any ongoing computations,
%% object bindings, and so on are forgotten, but the classpaths
%% and other node options are restored.
-spec recreate_node(node_id()) -> {ok,node_id()} | {error,any()}.

recreate_node(NodeId) ->
    {ok,Node} = node_lookup(NodeId),
    PreNode = Node#node{num_start_tries=0},
    spawn_java(PreNode,get_java_node_id()).

%% @doc
%% Brutally shuts down and attempts to terminate
remove_thread_mappings(NodeId) ->
    lists:foreach
      (fun ({Key={NodeIdKey,_},_}) ->
               if NodeId==NodeIdKey -> ets:delete(java_threads,Key);
                  true -> ok
               end;
           ({Pid,ThreadNodes}) ->
               NewThreadNodes =
                   lists:filter
                     (fun ({_,NodeId2}) -> NodeId=/=NodeId2 end,
                      ThreadNodes),
               ets:insert(java_threads,{Pid,NewThreadNodes})
       end, ets:tab2list(java_threads)).

remove_class_mappings(NodeId) ->
    Classes = ets:tab2list(java_classes),
    lists:foreach
      (fun ({Key,_Value}) ->
               case Key of
                   {NodeId,_} -> ets:delete(java_classes,Key);
                   _ -> ok
               end
       end, Classes).

%% @doc
%% Lets Java know that an object can be freed.
-spec free(object_ref()) -> any().
free(Object) ->
    javaCall(node_id(Object),?free,Object).

%% @doc Sets the timeout value for Java calls.
%% Calls to Java from the current Erlang process will henceforth
%% fail after Timeout seconds (or never is the argument is
%% the atom infinity).
%% Implementation note: this function stores data in the Erlang
%% process dictionary.
-spec set_timeout(integer() | infinity) -> any().
set_timeout(Timeout) ->
    case Timeout of
        _ when is_integer(Timeout), Timeout>=0 -> ok;
        infinity -> ok;
        _ -> throw(badarg)
    end,
    set_value(timeout,Timeout).

get_timeout(Node) ->
    get_value(timeout,Node#node.call_timeout).

set_value(ValueName,Value) ->
    PropList =
        case erlang:get({javaErlangOptions,self()}) of
            undefined ->
                [];
            Other ->
                proplists:delete(ValueName,Other)
        end,
    put({javaErlangOptions,self()},[{ValueName,Value}|PropList]).

get_value(ValueName,Default) ->
    case get({javaErlangOptions,self()}) of
        PropList when is_list(PropList) ->
            proplists:get_value(ValueName,PropList,Default);
        _ ->
            Default
    end.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% @doc
%% Returns true if its argument is a Java object reference, false otherwise.
-spec is_object_ref(any()) -> boolean().
is_object_ref({object,_,_,_,_}) ->
    true;
is_object_ref({executable,_,_}) ->
    true;
is_object_ref({thread,_,_}) ->
    true;
is_object_ref(_) ->
    false.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% @doc
%% Returns the elements of the (one-dimensional) array object argument
%% as an Erlang list of objects.
-spec array_to_list(object_ref()) -> [value()].
array_to_list(ArrayObj) ->
    javaCall(node_id(ArrayObj),?array_to_list,ArrayObj).

%% @doc
%% Creates a one-dimensional Java array populated with the elements
%% from the Erlang list argument, using the type specification
%% as an element recipe. Example:
%% ``java:list_to_array(NodeId,"Hello World!",char).''
-spec list_to_array(node_id(),[value()],type()) -> object_ref().
list_to_array(NodeId,List,Type) when is_list(List) ->
    javaCall(NodeId,?list_to_array,{Type,list_to_tuple(List)}).

%% @doc
%% Returns the elements of the Java String as an Erlang list.
-spec string_to_list(object_ref()) -> [char()].
string_to_list(String) ->
    Bytes = java:call(String,getBytes,[]),
    array_to_list(Bytes).

%% @doc
%% Returns the elements of the Java String as an UTF8 binary.
-spec string_to_utf8(object_ref()) -> binary().
string_to_utf8(String) ->
    UTF8String = list_to_string(node_id(String),"UTF-8"),
    Bytes = java:call(String,getBytes,[UTF8String]),
    list_to_binary
    (lists:map(fun (Byte) -> Byte band 255 end, array_to_list(Bytes))).

%% @doc
%% Converts the Erlang string argument to a Java string.
%% This function is for convenience only; it is implementable using
%% the rest of the Java API.
-spec list_to_string(node_id(),string()) -> object_ref().
list_to_string(NodeId,List) when is_list(List) ->
    java:new(NodeId,'java.lang.String',[List]).

%% @doc Widens or narrows a number.
-spec convert(node_id(),number_type(),java_number()) -> java_number().
convert(NodeId,Class,Number) when is_number(Number), is_atom(Class) ->
    javaCall(NodeId,?convert,{Class,Number}).

%% @doc
%% Returns true if the first parameter (a Java object) is an instant
%% of the class named by the second parameter.
%% This function is for convenience only; it is implementable using
%% the rest of the Java API.
-spec instanceof(object_ref(),class_name()) -> boolean().
instanceof(Obj,ClassName) when is_list(ClassName) ->
    instanceof(Obj,list_to_atom(ClassName));
instanceof(Object,ClassName) when is_atom(ClassName) ->
    javaCall(node_id(Object),?instof,{Object,ClassName}).

%% @doc Convenience method for determining subype relationship.
%% Returns true if the first argument is a subtype of the second.
-spec is_subtype(node_id(),class_name(),class_name()) -> boolean().
is_subtype(NodeId,Class1,Class2) when is_atom(Class1), is_atom(Class2) ->
    javaCall(NodeId,?is_subtype,{Class1,Class2}).

%% @doc
%% Returns the classname (as returned by the method getName() in
%% java.lang.Class)
%% of Java object parameter.
%% This function is for convenience only; it is implementable using
%% the rest of the Java API.
-spec getClassName(object_ref()) -> class_name().
getClassName(Object) ->
    getClassName(node_id(Object),Object).
-spec getClassName(node_id(),object_ref()) -> class_name().
getClassName(NodeId,Obj) ->
    javaCall(NodeId,?getClassName,Obj).

%% @doc
%% Returns the simple classname (as returned by the method getSimplename() in
%% java.lang.Class)
%% of Java object parameter.
%% This function is for convenience only; it is implementable using
%% the rest of the Java API.
-spec getSimpleClassName(object_ref()) -> class_name().
getSimpleClassName(Object) ->
    getSimpleClassName(node_id(Object),Object).
-spec getSimpleClassName(node_id(),object_ref()) -> class_name().
getSimpleClassName(NodeId,Obj) ->
    javaCall(NodeId,?getSimpleClassName,Obj).

%% @doc
%% Prints the Java stacktrace on the standard error file error descriptor
%% that resulted in the throwable object argument.
%% This function is for convenience only; it is implementable using
%% the rest of the Java API.
-spec print_stacktrace(object_ref()) -> any().
print_stacktrace(Exception) ->
    Err = get_static(node_id(Exception),'java.lang.System',err),
    call(Exception,printStackTrace,[Err]).

%% @doc
%% Returns the Java stacktrace as an Erlang list.
%% This function is for convenience only; it is implementable using
%% the rest of the Java API.
-spec get_stacktrace(object_ref()) -> list().
get_stacktrace(Exception) ->
    StringWriter = new(node_id(Exception),'java.io.StringWriter',[]),
    PrintWriter = new(node_id(Exception),'java.io.PrintWriter',[StringWriter]),
    call(Exception,printStackTrace,[PrintWriter]),
    string_to_list(call(StringWriter,toString,[])).


%% @doc
%% Returns an integer corresponding to the number of Java object that are
%% currently known to the Erlang part of the java library.
-spec memory_usage() -> integer().
memory_usage() ->
    0.

%% @doc
%% Returns an integer corresponding to the number of Java object that are
%% currently known to the Java part of the java library, at the node argument.
-spec memory_usage(node_id()) -> integer().
memory_usage(NodeId) ->
    javaCall(NodeId,?memoryUsage,void).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% @private
-spec acquire_class(node_id(),class_ref()) -> #class{}.
acquire_class(NodeId,ClassName) ->
    ?LOG("acquire_class(~p,~p)~n",[NodeId,ClassName]),
    acquire_class_int(NodeId,ClassName,void).

%% @private
-spec acquire_class(node_id(),class_ref(),class_name()) -> #class{}.
acquire_class(NodeId,ClassName,RealClassName) ->
    ?LOG("acquire_class(~p,~p)~n",[NodeId,ClassName]),
    acquire_class_int(NodeId,ClassName,RealClassName).

acquire_class_int(NodeId,ClassName,RealClassName) when is_atom(ClassName), 
						       is_atom(RealClassName) ->
    case class_lookup(NodeId,ClassName) of
	{ok,Class} ->
	    Class;
	_ ->
	    case get_load_permission(NodeId,ClassName) of
		ok ->
		    try java_to_erlang:compute_class(NodeId,ClassName,RealClassName) of
			Class ->
			    ets:delete(java_classes,{loading,NodeId,ClassName}),
			    class_store(NodeId,ClassName,Class)
		    catch ExceptionClass:Reason ->
			    ets:delete(java_classes,{loading,NodeId,ClassName}),
			    erlang:raise(ExceptionClass,Reason,erlang:get_stacktrace())
		    end
	    end
    end;
acquire_class_int(NodeId,ClassRef,RealClassName) when is_tuple(ClassRef),
						      is_atom(RealClassName) ->
    case get_load_permission(NodeId,ClassRef) of
	ok ->
	    try java_to_erlang:compute_class(NodeId,ClassRef,RealClassName) of
		Class ->
		    ets:delete(java_classes,{loading,NodeId,ClassRef}),
		    ClassName =
			list_to_atom(string_to_list(call(ClassRef,getCanonicalName,[]))),
		    class_store(NodeId,ClassName,Class)
	    catch ExceptionClass:Reason ->
		    ets:delete(java_classes,{loading,NodeId,ClassRef}),
		    erlang:raise(ExceptionClass,Reason,erlang:get_stacktrace())
	    end
    end.

%% Since classes can be loaded from multiple processes simultaneously
%% we have to serialize such attempts.
get_load_permission(NodeId,ClassName) ->
    case ets:insert_new(java_classes,{{loading,NodeId,ClassName},self()}) of
        true ->
            ok;
        false ->
            timer:sleep(10),
            get_load_permission(NodeId,ClassName)
    end.

class_lookup(NodeId,ClassName) when is_atom(ClassName) ->
    Key = {NodeId,ClassName},
    case ets:lookup(java_classes,Key) of
        [{_,Class}] ->
            {ok,Class};
        _ ->
            false
    end.

class_store(NodeId,ClassName,Class) when is_atom(ClassName) ->
    java:format(debug,"Storing class info for class ~p~n",[ClassName]),
    ets:insert(java_classes,{{NodeId,ClassName},Class}),
    ets:insert(java_class_ids,{{NodeId,Class#class.id},Class}),
    Class.

%% @private
node_lookup(NodeId) ->
    node_lookup(NodeId,true).

node_lookup(NodeId,Warn) ->
    case ets:lookup(java_nodes,NodeId) of
        [{_,Node}] ->
            {ok,Node};
        _ ->
            if
                Warn ->
                    format(error,"~p: node_lookup(~p) failed??~n",[self(),NodeId]),
                    format(error,"Stacktrace:~n~p~n",[gen_stacktrace()]),
                    false;
                true ->
                    false
            end
    end.

gen_stacktrace() ->
    try throw(bad)
    catch _:_ -> erlang:get_stacktrace() end.

node_store(Node) ->
    ets:insert(java_nodes,{Node#node.node_id,Node}).

%% @private
find_class(Object) ->
    case permit_output(get_loglevel(),debug) of
      true ->
	java:format
	  (debug,"find_class(~p)~n",[Object]);
      false ->
	ok
    end,
    ClassId = class_id(Object),
    NodeId = node_id(Object),
    case ets:lookup(java_class_ids,{NodeId,ClassId}) of
        [{_,Class}] -> Class;
        _ ->
            ClassName = getClassName(NodeId,Object),
            Class = acquire_class(NodeId,ClassName),
            Class
    end.

%% firstComponent(Atom) when is_atom(Atom) ->
%%   list_to_atom(firstComponent(atom_to_list(Atom)));
%% firstComponent(Atom) when is_list(Atom) ->
%%   case string:chr(Atom,$.) of
%%     0 -> Atom;
%%     N -> string:substr(Atom,1,N-1)
%%   end.

%% @private
finalComponent(Atom) when is_atom(Atom) ->
    list_to_atom(finalComponent(atom_to_list(Atom)));
finalComponent(Atom) when is_list(Atom) ->
    case string:rchr(Atom,$.) of
        0 -> Atom;
        N -> string:substr(Atom,N+1)
    end.

ensure_non_null(Object) ->
    if
        Object==null ->
            format(warning,"~n*** Warning: null object~n",[]),
            throw(badarg);
        true -> ok
    end.

msgtype_to_list(Type) ->
  case Type of
    0 ->
      "identity";
    1 ->
      "reset";
    2 ->
      "terminate";
    3 ->
      "connect";
    4 ->
      "getConstructors";
    5 ->
      "lookupClass";
    6 ->
      "getClassLocation";
    7 ->
      "getMethods";
    8 ->
      "getClasses";
    9 ->
      "getFields";
    10 ->
      "getConstructor";
    11 ->
      "getMethod";
    12 ->
      "getField";
    13 ->
      "objTypeCompat";
    14 ->
      "createThread";
    15 ->
      "stopThread";
    16 ->
      "free";
    17 ->
      "freeInstance";
    18 ->
      "memoryUsage";
    19 -> 
      "new_proxy_class";
    20 ->
      "new_proxy_object";
    21 ->
      "proxy_reply";
    51 ->
      "call_method";
    52 ->
      "call_constructor";
    53 ->
      "getFieldValue";
    54 ->
      "setFieldValue";
    55 ->
      "getClassName";
    56 ->
      "array_to_list";
    57 ->
      "list_to_array";
    58 ->
      "instof";
    59 ->
      "convert";
    60 ->
      "is_subtype";
    61 ->
      "getSimpleClassName";

    N ->
      "?? unknown tag "++integer_to_list(N)
  end.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


runs_on_windows() ->
    case os:type() of
        {win32,_} ->
            true;
%%        {win64,_} ->
%%            true;
        _ ->
            false
    end.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%% Rudimentary logging support; in the future we should probably use
%% a standard logger

get_option(Name) ->
    case get_node_options() of
        undefined ->
            default_option(Name);
        Options ->
            case proplists:get_value(Name, Options) of
                undefined ->
                    default_option(Name);
                Value ->
                    Value
            end
    end.

get_options() ->
    case get_node_options() of
        undefined -> default_options();
        Options -> Options
    end.

get_node_options() ->
    case ets:info(java_nodes) of
        undefined ->
            undefined;
        _ ->
            case ets:lookup(java_nodes, options) of
                [{_, Options}] ->
                    Options;
                [] ->
                    undefined
            end
    end.

%% @doc
%% Determines how much debugging information is displayed.
%%
-spec set_loglevel(Level::loglevel()) -> any().
set_loglevel(Level) ->
    user_level(Level),
    case init([{log_level,Level}]) of
        true -> ok;
        false ->
            Options = get_options(),
            ets:insert(java_nodes,{options,[{log_level,Level}|Options]})
    end.

get_loglevel() ->
    get_option(log_level).

%% @private
format(Level,Message) ->
    level(Level),
    case permit_output(get_loglevel(),Level) of
        true -> io:format(Message);
        _ -> ok
    end.

%% @private
format(Level,Format,Message) ->
    level(Level),
    case permit_output(get_loglevel(),Level) of
        true -> io:format(Format,Message);
        _ -> ok
    end.

permit_output(LevelInterest,LevelOutput) ->
    user_level(LevelInterest) >= level(LevelOutput).

user_level(none) -> -1;
user_level(all) -> 100;
user_level(Other) -> level(Other).

level(emergency) -> 0;
level(alert) -> 1;
level(critical) -> 2;
level(error) -> 3;
level(warning) -> 4;
level(notice) -> 5;
level(info) -> 6;
level(debug) -> 7;
level(_) -> throw(badarg).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% @doc Outputs to standard output a textual representation
%% of what the library knows about a certain Java class.
%% Mainly useful as a debugging aid.
%%
-spec print_class(node_id(),class_ref()) -> any().
print_class(NodeId,ClassName) ->
  Class = acquire_class(NodeId,ClassName),
  Pre = fun () -> "    " end,
  Combiner = fun () -> "\n" end,
  String =
    print_term(Class#class.name) ++ ": \n" ++
    "  id = " ++ print_term(Class#class.id)
    ++ ",\n" ++ "  constructors = [\n" 
    ++ print_elements(element(1,Class#class.constructors),fun print_constructor/1,Pre,Combiner) 
    ++ "\n  ]"
    ++ ",\n" ++ "  methods = [\n" 
    ++ print_elements(element(1,Class#class.methods),fun print_method/1,Pre,Combiner) 
    ++ "\n  ]"
    ++ ",\n" ++ "  static_methods = [\n" 
    ++ print_elements(element(1,Class#class.static_methods),fun print_method/1,Pre,Combiner) 
    ++ "\n  ]"
    ++ ",\n" ++ "  fields = [\n" 
    ++ print_elements(Class#class.fields,
		      fun (Field) -> print_field(Field,Pre) end,
		      Pre,
		      Combiner)
    ++ "\n  ]"
    ++ ",\n" ++ "  static_fields = [\n" 
    ++ print_elements(Class#class.static_fields,
		      fun (Field) -> print_field(Field,Pre) end,
		      Pre,
		      Combiner)
    ++ "\n  ]"
    ++ "\n",
  io:format("~s~n",[String]).

print_elements(Elements,Printer,Pre,Combiner) ->
  lists:foldr
    (fun (Element,Acc) ->
	 String = Pre() ++ Printer(Element),
	 if
	   Acc=="" -> String;
	   true -> Acc++Combiner()++String
	 end
     end, "", Elements).

print_method({{Name,ArgTypes},_}) ->
  io_lib:format("~p",[Name])++print_args(ArgTypes).
    
print_constructor({{_,ArgTypes},_}) ->
  print_args(ArgTypes).

print_args(ArgTypes) ->
  Pre = fun () -> "" end,
  Combiner = fun () -> "," end,
  "(" ++ print_elements(ArgTypes,fun print_type/1,Pre,Combiner) ++ ")".

print_type(Type) ->
  case Type of
    {array,ArrayType,0} ->
      print_type(ArrayType);
    {array,ArrayType,Dimension} ->
      print_type({array,ArrayType,Dimension-1})++"[]";
    NoArrayType ->
      io_lib:format("~p",[NoArrayType])
  end.

print_field({{Name,_},Vars},Pre) ->
  print_elements
    (Vars,
     fun ({[Type],_}) ->
	 io_lib:format("~p",[Name])++":"++print_type(Type)
     end,
     fun () -> "" end,
     Pre).

print_term(Term) ->
  io_lib:format("~p",[Term]).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

-ifdef(non_deprecated_erlang_now).
java_timestamp() ->
    erlang:now().
-else.
java_timestamp() ->
    erlang:timestamp().
-endif.
